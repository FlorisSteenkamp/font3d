import * as __WEBPACK_EXTERNAL_MODULE_react__ from "react";
/******/ var __webpack_modules__ = ({

/***/ 824:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Font3d = void 0;
const React = __webpack_require__(810);
const init_buffers_1 = __webpack_require__(347);
const draw_scene_1 = __webpack_require__(728);
const init_shader_1 = __webpack_require__(716);
const init_texture_promise_1 = __webpack_require__(42);
const Font3d = React.memo(function (props) {
    const { fontSize, effectsState, height, models, triangleCounts, positionedGlyphs } = props;
    const { textureUrl } = effectsState.material;
    const $div = React.useRef(null);
    const $canvas = React.useRef(null);
    const $glInfo = React.useRef({});
    const $glState = React.useRef({
        initialized: false,
        buffersMap: new Map()
    });
    const $prevRenderInfo = React.useRef({});
    function changeCanvasWidth(entries) {
        if (!entries.length) {
            return;
        }
        const entry = entries[0];
        const canvas = $canvas.current;
        if (canvas === null) {
            return;
        }
        canvas.width = entry.contentRect.width;
        drawScene_();
    }
    React.useEffect(() => {
        const div = $div.current;
        const canvas = $canvas.current;
        const glInfo = $glInfo.current;
        const glState = $glState.current;
        if (glInfo.gl === undefined) {
            glInfo.gl = canvas.getContext('webgl2');
        }
        const renderInfo = $prevRenderInfo.current;
        renderInfo.textureUrl = textureUrl;
        (0, init_shader_1.initShader_)(glInfo);
        (0, init_texture_promise_1.initTexturePromise)(glInfo, renderInfo.textureUrl)
            .then(() => {
            glState.initialized = true;
            const observer = new window.ResizeObserver(changeCanvasWidth);
            observer.observe(div); // Will also draw scene initially.
        });
    }, []);
    async function drawScene_() {
        const glInfo = $glInfo.current;
        const glState = $glState.current;
        if (!glState.initialized) {
            return;
        }
        const prevRenderInfo = $prevRenderInfo.current;
        const { textureUrl: textureUrl_ } = prevRenderInfo;
        if (textureUrl !== textureUrl_) {
            prevRenderInfo.textureUrl = textureUrl;
            await (0, init_texture_promise_1.initTexturePromise)(glInfo, prevRenderInfo.textureUrl);
        }
        const gl = glInfo.gl;
        glInfo.triangleCounts = triangleCounts;
        const { shaderInfo, texture, textureMetrics, } = glInfo;
        // const languageTags = getLanguageTagsFromBrowser();
        // const positionedGlyphs = textToGlyphsLayout(
        //     font, text, fontSize, languageTags, {
        //         smcp: true,  // always a required feature
        //     }// features TODO2
        // );
        const scale = 1 / fontSize;
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        const { buffersMap /*, textModels*/ } = glState;
        const len = positionedGlyphs.length;
        const bufferss = [];
        for (let i = 0; i < len; i++) {
            const model = models[i];
            let buffers = glState.buffersMap.get(model);
            if (buffers === undefined) {
                buffers = (0, init_buffers_1.initBuffers)(gl, model);
                buffersMap.set(model, buffers);
            }
            bufferss.push(buffers);
        }
        for (let i = 0; i < len; i++) {
            const positionedGlyph = positionedGlyphs[i];
            const glInfo = {
                fontSize,
                gl, shaderInfo, texture, textureMetrics,
                buffers: bufferss[i],
                triangleCount: triangleCounts[i],
                xOffset: scale * positionedGlyph.x
            };
            glInfo.gl = gl;
            (0, draw_scene_1.drawScene)(glInfo, "orthogonal", effectsState);
        }
    }
    drawScene_();
    return (React.createElement("div", { ref: $div, style: { display: 'block', margin: 'auto', border: '1px solid #ddd' } },
        React.createElement("canvas", { ref: $canvas, height: height })));
});
exports.Font3d = Font3d;


/***/ }),

/***/ 728:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.drawScene = void 0;
const projection_to_cartesian_1 = __webpack_require__(975);
const initialize_render_1 = __webpack_require__(838);
/**
 *
 * @param glInfo
 * @param projection
 * @param effectsState
 */
function drawScene(glInfo, projection, effectsState) {
    const { gl, shaderInfo, buffers, triangleCount, texture, textureMetrics, xOffset, fontSize } = glInfo;
    const { width: textureWidth } = textureMetrics;
    const { orientation, lighting, options, material } = effectsState;
    const { wireframe } = options;
    const { color: materialColor, textureRepeatCountX, textureRepeatCountY } = material;
    const { modelViewMatrix, normalMatrix, projectionMatrix } = (0, initialize_render_1.initializeRender)(gl, projection, orientation, fontSize);
    const { attribLocations, uniformLocations } = shaderInfo;
    const { 
    /*aVertexColor, */ aVertexNormal, aVertexPosition, aWireframeCoord, aTextureCoord } = attribLocations;
    const { uTextureRepeatCountX, uTextureRepeatCountY, uAmbientColor, uDirectionalColor, uDirectionalDirection, uModelViewMatrix, uNormalMatrix, uProjectionMatrix, uSampler, uWireframe, uTextureWidth, uXOffset, uVertexColor } = uniformLocations;
    enableBuffer(gl, buffers.vertex, aVertexPosition, 3, gl.FLOAT);
    // enableBuffer(gl, buffers.color, aVertexColor, 4, gl.FLOAT);
    enableBuffer(gl, buffers.normal, aVertexNormal, 3, gl.FLOAT);
    enableBuffer(gl, buffers.wireframeVertices, aWireframeCoord, 3, gl.FLOAT);
    enableBuffer(gl, buffers.textureCoord, aTextureCoord, 2, gl.FLOAT);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.vertexIndex);
    // Tell WebGL to use our program when drawing
    gl.useProgram(shaderInfo.program);
    // Set the shader uniforms
    gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
    gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);
    gl.uniformMatrix4fv(uNormalMatrix, false, normalMatrix);
    gl.activeTexture(gl.TEXTURE0);
    // Bind the texture to texture unit 0
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // Tell the shader we bound the texture to texture unit 0
    gl.uniform1i(uSampler, 0);
    const { ambient, directional } = lighting;
    gl.uniform4f(uVertexColor, ...materialColor, 1);
    gl.uniform1f(uTextureRepeatCountX, textureRepeatCountX);
    gl.uniform1f(uTextureRepeatCountY, textureRepeatCountY);
    const { brightness: b } = ambient;
    gl.uniform3f(uAmbientColor, b, b, b);
    gl.uniform1i(uWireframe, wireframe ? 1 : 0);
    gl.uniform1f(uXOffset, xOffset);
    const { brightness: db, direction, distance } = directional;
    gl.uniform3f(uDirectionalColor, db, db, db);
    const [x, y, z] = (0, projection_to_cartesian_1.projectionToCartesian)(direction, distance);
    gl.uniform3f(uDirectionalDirection, x, y, z);
    gl.uniform1i(uTextureWidth, textureWidth);
    if (wireframe) {
        gl.drawArrays(gl.LINES, 0, 6 * triangleCount);
    }
    else {
        gl.drawElements(gl.TRIANGLES, 3 * triangleCount, gl.UNSIGNED_SHORT, 0);
    }
}
exports.drawScene = drawScene;
function enableBuffer(gl, buffer, index, size, type) {
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.vertexAttribPointer(index, size, type, false, 0, 0);
    gl.enableVertexAttribArray(index);
}


/***/ }),

/***/ 347:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initBuffers = void 0;
function initBuffers(gl, model) {
    const { vertices, vertexColors, vertexNormals, vertexIndices, textureCoords, wireframeVertices } = model;
    const vertexBuffer = createAndLoadBuffer(gl, Float32Array, vertices);
    const colorBuffer = createAndLoadBuffer(gl, Float32Array, vertexColors);
    const textureCoordBuffer = createAndLoadBuffer(gl, Float32Array, textureCoords);
    const normalBuffer = createAndLoadBuffer(gl, Float32Array, vertexNormals);
    const wireframeVertexBuffer = createAndLoadBuffer(gl, Float32Array, wireframeVertices);
    // ----- VERTEX INDICES -----//
    const vertexIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexIndices), gl.STATIC_DRAW);
    return {
        vertex: vertexBuffer,
        normal: normalBuffer,
        color: colorBuffer,
        textureCoord: textureCoordBuffer,
        wireframeVertices: wireframeVertexBuffer,
        vertexIndex: vertexIndexBuffer
    };
}
exports.initBuffers = initBuffers;
function createAndLoadBuffer(gl, constructor, values) {
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new constructor(values), gl.STATIC_DRAW);
    return buffer;
}


/***/ }),

/***/ 45:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initShader = void 0;
/*
 * Initialize a shader program, so WebGL knows how to draw our data
 */
function initShader(gl, vs, fs) {
    let vertexShader = loadShader(gl, gl.VERTEX_SHADER, vs);
    let fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fs);
    // Create the shader program
    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    // If creating the shader program failed, alert
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
        return null;
    }
    return {
        program: shaderProgram,
        attribLocations: {
            aVertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
            aVertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'),
            // aVertexColor    : gl.getAttribLocation(shaderProgram, 'aVertexColor'),
            aTextureCoord: gl.getAttribLocation(shaderProgram, "aTextureCoord"),
            aWireframeCoord: gl.getAttribLocation(shaderProgram, "aWireframeCoord"),
        },
        uniformLocations: {
            uProjectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
            uModelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
            uNormalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
            uAmbientColor: gl.getUniformLocation(shaderProgram, 'uAmbientColor'),
            uDirectionalColor: gl.getUniformLocation(shaderProgram, 'uDirectionalColor'),
            uDirectionalDirection: gl.getUniformLocation(shaderProgram, 'uDirectionalDirection'),
            uSampler: gl.getUniformLocation(shaderProgram, "uSampler"),
            uWireframe: gl.getUniformLocation(shaderProgram, "uWireframe"),
            uTextureWidth: gl.getUniformLocation(shaderProgram, "uTextureWidth"),
            uXOffset: gl.getUniformLocation(shaderProgram, "uXOffset"),
            uVertexColor: gl.getUniformLocation(shaderProgram, "uVertexColor"),
            uTextureRepeatCountX: gl.getUniformLocation(shaderProgram, "uTextureRepeatCountX"),
            uTextureRepeatCountY: gl.getUniformLocation(shaderProgram, "uTextureRepeatCountY"),
        },
    };
}
exports.initShader = initShader;
/*
 * creates a shader of the given type, uploads the source and
 * compiles it.
 */
function loadShader(gl, type, source) {
    const shader = gl.createShader(type);
    // Send the source to the shader object
    gl.shaderSource(shader, source);
    // Compile the shader program
    gl.compileShader(shader);
    // See if it compiled successfully
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}


/***/ }),

/***/ 42:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initTexturePromise = void 0;
const load_texture_1 = __webpack_require__(301);
async function initTexturePromise(glInfo, textureUrl) {
    const gl = glInfo.gl;
    const textureInfo = await (0, load_texture_1.loadTexture)(gl, textureUrl);
    const { texture, width, height } = textureInfo;
    const textureMetrics = { width, height };
    glInfo.texture = texture;
    glInfo.textureMetrics = textureMetrics;
}
exports.initTexturePromise = initTexturePromise;


/***/ }),

/***/ 838:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initializeRender = void 0;
const mat4_1 = __webpack_require__(490);
function initializeRender(gl, projection, orientation, fontSize) {
    const canvas = gl.canvas;
    const { clientWidth, clientHeight } = canvas;
    const aspectRatio = clientWidth / clientHeight;
    gl.viewport(0, 0, aspectRatio * fontSize, fontSize);
    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.clearDepth(1.0); // Clear everything
    gl.enable(gl.DEPTH_TEST); // Enable depth testing
    gl.depthFunc(gl.LEQUAL); // Near things obscure far things
    // gl.enable(gl.CULL_FACE);
    // gl.cullFace(gl.BACK);
    const fieldOfView = 45 * (Math.PI / 180); // in radians
    const zNear = 0.1;
    const zFar = 10.0;
    const projectionMatrix = projection === 'orthogonal'
        ? (0, mat4_1.ortho)(0, aspectRatio, -1, 0, zNear, zFar)
        : (0, mat4_1.perspective)(fieldOfView, aspectRatio, zNear, zFar);
    // Set the drawing position to the "identity" point, which is
    // the center of the scene.
    let modelViewMatrix = (0, mat4_1.createUnitMat4)();
    modelViewMatrix = (0, mat4_1.translate)(modelViewMatrix, [0.0, 0.0, -1.0]);
    modelViewMatrix = (0, mat4_1.rotate)(modelViewMatrix, orientation.z, [0, 0, 1]);
    modelViewMatrix = (0, mat4_1.rotate)(modelViewMatrix, orientation.x, [0, 1, 0]);
    modelViewMatrix = (0, mat4_1.rotate)(modelViewMatrix, orientation.y, [1, 0, 0]);
    let normalMatrix = (0, mat4_1.transpose)((0, mat4_1.invert)(modelViewMatrix));
    return { projectionMatrix, modelViewMatrix, normalMatrix };
}
exports.initializeRender = initializeRender;


/***/ }),

/***/ 301:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadTexture = void 0;
/**
 * Initialize a texture and load an image.
 * When the image finished loading copy it into the texture.
 *
 * @param gl
 * @param url
 */
async function loadTexture(gl, url) {
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // Because images have to be downloaded over the internet they might take
    // a moment until they are ready. Until then put a single pixel in the
    // texture so we can use it immediately. When the image has finished
    // downloading we'll update the texture with the contents of the image.
    const level = 0;
    const internalFormat = gl.RGBA;
    const srcFormat = gl.RGBA;
    const srcType = gl.UNSIGNED_BYTE;
    const img = new Image();
    img.src = url;
    await img.decode();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, img);
    // WebGL1 has different requirements for power of 2 images
    // vs. non power of 2 images so check if the image is a
    // power of 2 in both dimensions.
    if (isPowerOf2(img.width) && isPowerOf2(img.height)) {
        // Yes, it's a power of 2. Generate mips.
        gl.generateMipmap(gl.TEXTURE_2D);
    }
    else {
        // No, it's not a power of 2. Turn off mips and set
        // wrapping to clamp to edge
        // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    }
    return {
        texture: texture,
        width: img.width,
        height: img.height
    };
}
exports.loadTexture = loadTexture;
function isPowerOf2(value) {
    return (value & (value - 1)) === 0;
}


/***/ }),

/***/ 975:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.projectionToCartesian = void 0;
/**
 * Transforms a point in 3d defined by its xy projection onto a half-sphere with
 * radius `distance` centered at the origin
 * @param p The 2d point representing the direction vector.
 * @param distance The distance of the light source to [0,0,0].
 */
function projectionToCartesian(p = [0, 0], distance = 1) {
    let [x, y] = p;
    // Ensure point is within unit circle - the interface gave us a unit square.
    let d2 = x ** 2 + y ** 2;
    if (d2 > 1) {
        let d_ = Math.sqrt(d2);
        x = x / d_;
        y = y / d_;
        d2 = 1;
    }
    // First let's calculate the 3d position of the point on the hemisphere with
    // radius 1.
    // x**2 + y**2 + z**2 must = 1 => z = sqrt(1-x**2-y**2) = sqrt(1-d2)
    let z = Math.sqrt(1 - d2);
    // Now lets scale the 3d vector 
    x = x * distance;
    y = y * distance;
    z = z * distance;
    return [x, y, z];
}
exports.projectionToCartesian = projectionToCartesian;


/***/ }),

/***/ 997:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fsStr = void 0;
const frag = (x) => x;
let fsStr = frag `
    precision highp float;

    uniform highp int uWireframe;
    uniform highp int uTextureWidth;
    uniform sampler2D uSampler;
    uniform vec3 uAmbientColor;
    uniform vec3 uDirectionalColor;
    uniform vec3 uDirectionalDirection;
    uniform vec4 uVertexColor;
    uniform highp float uTextureRepeatCountX;
    uniform highp float uTextureRepeatCountY;

    varying vec3 normalInterp;
    varying vec3 vertPos;
    // varying vec4 vColor;
    varying highp vec2 vTextureCoord;

    const vec3 specColor = vec3(0.1, 0.1, 0.1);

    highp float textureWidth = float(uTextureWidth);

    void main() {
        highp vec3 fColor = uWireframe == 1
            ? uVertexColor.xyz
            : texture2D(
                uSampler,
                vec2(
                    vTextureCoord.x*textureWidth*uTextureRepeatCountX,
                    vTextureCoord.y*uTextureRepeatCountY
                )
            ).xyz;

        vec3 normal_ = normalize(normalInterp);
        vec3 lightDir = normalize(uDirectionalDirection - vertPos);

        float lambertian = max(dot(lightDir,normal_), 0.0);
        float specular = 0.0;

        if (lambertian > 0.0) {
            vec3 viewDir = normalize(-vertPos);

            // Blinn Phong
            // vec3 halfDir = normalize(lightDir + viewDir);
            // float specAngle = max(dot(halfDir, normal_), 0.0);
            // specular = pow(specAngle, 16.0);

            // Phong
            vec3 reflectDir = reflect(-lightDir, normal_);
            float specAngle = max(dot(reflectDir, viewDir), 0.0);
            specular = pow(specAngle, 16.0/4.0);
        }

        vec3 ambient_ = fColor * uAmbientColor;
        vec3 directional_ = fColor * uDirectionalColor * lambertian;
        vec3 specular_ = specular * specColor; 

        vec3 color = ambient_ + directional_ + specular_;
        vec3 color_ = vec3(color[0], color[1], color[2]);

        gl_FragColor = uWireframe == 1
            ? uVertexColor
            : vec4(color + specular_, 1.0);
    }
`;
exports.fsStr = fsStr;


/***/ }),

/***/ 578:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.vsStr = void 0;
const vert = (x) => x;
const vsStr = vert `
    precision highp float;

    uniform highp int uWireframe;
    uniform mat4 uNormalMatrix;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;
    uniform highp float uXOffset;

    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;
    attribute vec3 aWireframeCoord;

    varying vec3 normalInterp;
    varying vec3 vertPos;
    varying highp vec2 vTextureCoord;

    void main() {
        highp vec3 vertexPosition = vec3(
            aVertexPosition.x + uXOffset,
            aVertexPosition.yz
        );

        highp vec3 wireframeCoord = vec3(
            aWireframeCoord.x + uXOffset,
            aWireframeCoord.yz
        );

        uWireframe == 1
            ? gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(wireframeCoord, 1.0)
            : gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(vertexPosition, 1.0);

        vec4 vertPos4 = uModelViewMatrix * vec4(aVertexPosition, 1.0);
        vertPos = vec3(vertPos4) / vertPos4.w;
        normalInterp = vec3(uNormalMatrix * vec4(aVertexNormal, 0.0));
        vTextureCoord = aTextureCoord;
    }
`;
exports.vsStr = vsStr;


/***/ }),

/***/ 716:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initShader_ = void 0;
const init_shader_1 = __webpack_require__(45);
const fs_1 = __webpack_require__(997);
const vs_1 = __webpack_require__(578);
function initShader_(glInfo) {
    const shaderInfo = (0, init_shader_1.initShader)(glInfo.gl, vs_1.vsStr, fs_1.fsStr);
    glInfo.shaderInfo = shaderInfo;
}
exports.initShader_ = initShader_;


/***/ }),

/***/ 490:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.transpose = exports.rotate = exports.translate = exports.perspective = exports.ortho = exports.invert = exports.createUnitMat4 = void 0;
// TODO2 - fix
//const EPSILON = 0.000001
/**
 * Inverts a mat4
 *
 * @param a the source matrix
 */
function invert(a) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
        return undefined;
    }
    det = 1 / det;
    return [
        (a11 * b11 - a12 * b10 + a13 * b09) * det,
        (a02 * b10 - a01 * b11 - a03 * b09) * det,
        (a31 * b05 - a32 * b04 + a33 * b03) * det,
        (a22 * b04 - a21 * b05 - a23 * b03) * det,
        (a12 * b08 - a10 * b11 - a13 * b07) * det,
        (a00 * b11 - a02 * b08 + a03 * b07) * det,
        (a32 * b02 - a30 * b05 - a33 * b01) * det,
        (a20 * b05 - a22 * b02 + a23 * b01) * det,
        (a10 * b10 - a11 * b08 + a13 * b06) * det,
        (a01 * b08 - a00 * b10 - a03 * b06) * det,
        (a30 * b04 - a31 * b02 + a33 * b00) * det,
        (a21 * b02 - a20 * b04 - a23 * b00) * det,
        (a11 * b07 - a10 * b09 - a12 * b06) * det,
        (a00 * b09 - a01 * b07 + a02 * b06) * det,
        (a31 * b01 - a30 * b03 - a32 * b00) * det,
        (a20 * b03 - a21 * b01 + a22 * b00) * det
    ];
}
exports.invert = invert;
/**
 * Returns an orthogonal projection matrix with the given bounds.
 *
 * The near/far clip planes correspond to a normalized device coordinate Z
 * range of [-1, 1], which matches WebGL/OpenGL's clip volume.
 *
 * @param left Left bound of the frustum
 * @param right Right bound of the frustum
 * @param bottom Bottom bound of the frustum
 * @param top Top bound of the frustum
 * @param near Near bound of the frustum
 * @param far Far bound of the frustum
 */
function ortho(left, right, bottom, top, near, far) {
    const m = [];
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    m.push(-2 * lr);
    m.push(0, 0, 0, 0);
    m.push(-2 * bt);
    m.push(0, 0, 0, 0);
    m.push(2 * nf);
    m.push(0);
    m.push((left + right) * lr);
    m.push((top + bottom) * bt);
    m.push((far + near) * nf);
    m.push(1);
    return m;
}
exports.ortho = ortho;
function perspective(fovy, aspect, near, far) {
    const m = [];
    const f = 1.0 / Math.tan(fovy / 2);
    m.push(f / aspect);
    m.push(0, 0, 0, 0);
    m.push(f);
    m.push(0, 0, 0, 0);
    const nf = 1 / (near - far);
    m.push(far === Number.POSITIVE_INFINITY ? -1 : (far + near) * nf);
    m.push(-1);
    m.push(0, 0);
    m.push(far === Number.POSITIVE_INFINITY ? 2 * far * near * nf : -2 * near);
    m.push(0);
    return m;
}
exports.perspective = perspective;
function createUnitMat4() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
exports.createUnitMat4 = createUnitMat4;
function translate(a, v) {
    const m = a.slice();
    const x = v[0];
    const y = v[1];
    const z = v[2];
    m[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    m[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    m[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    m[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    return m;
}
exports.translate = translate;
function rotate(a, rad, axis) {
    let x = axis[0];
    let y = axis[1];
    let z = axis[2];
    let len = Math.sqrt(x * x + y * y + z * z);
    // if (len < EPSILON) { return undefined; }
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const t = 1 - c;
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const b00 = x * x * t + c;
    const b01 = y * x * t + z * s;
    const b02 = z * x * t - y * s;
    const b10 = x * y * t - z * s;
    const b11 = y * y * t + c;
    const b12 = z * y * t + x * s;
    const b20 = x * z * t + y * s;
    const b21 = y * z * t - x * s;
    const b22 = z * z * t + c;
    return [
        a00 * b00 + a10 * b01 + a20 * b02,
        a01 * b00 + a11 * b01 + a21 * b02,
        a02 * b00 + a12 * b01 + a22 * b02,
        a03 * b00 + a13 * b01 + a23 * b02,
        a00 * b10 + a10 * b11 + a20 * b12,
        a01 * b10 + a11 * b11 + a21 * b12,
        a02 * b10 + a12 * b11 + a22 * b12,
        a03 * b10 + a13 * b11 + a23 * b12,
        a00 * b20 + a10 * b21 + a20 * b22,
        a01 * b20 + a11 * b21 + a21 * b22,
        a02 * b20 + a12 * b21 + a22 * b22,
        a03 * b20 + a13 * b21 + a23 * b22,
        a[12],
        a[13],
        a[14],
        a[15]
    ];
}
exports.rotate = rotate;
function transpose(a) {
    return [
        a[0], a[4], a[8], a[12],
        a[1], a[5], a[9], a[13],
        a[2], a[6], a[10], a[14],
        a[3], a[7], a[11], a[15]
    ];
}
exports.transpose = transpose;


/***/ }),

/***/ 810:
/***/ ((module) => {

var x = y => { var x = {}; __webpack_require__.d(x, y); return x; }
var y = x => () => x
module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;

Object.defineProperty(exports, "X", ({ value: true }));
exports.T = void 0;
const font3d_1 = __webpack_require__(824);
Object.defineProperty(exports, "T", ({ enumerable: true, get: function () { return font3d_1.Font3d; } }));

})();

var __webpack_exports__Font3d = __webpack_exports__.T;
var __webpack_exports___esModule = __webpack_exports__.X;
export { __webpack_exports__Font3d as Font3d, __webpack_exports___esModule as __esModule };
